import type { ImageContour } from './ImageProcessor';

export interface GCodeGeneratorConfig {
  strategy: 'contour' | 'pocket' | 'engrave';
  toolDiameter: number;
  passingDepth: number;
  finalDepth: number;
  safeZ: number;
  feedRate: number;
  plungeRate: number;
  spindleSpeed: number;
  stepover: number;
}

export function generateGCodeFromImage(
  contours: ImageContour[],
  config: GCodeGeneratorConfig
): string {
  const lines: string[] = [];

  lines.push('; Generated by CNC Simulator - Image to G-Code');
  lines.push('; Strategy: ' + config.strategy.toUpperCase());
  lines.push('; Tool: Ã˜' + config.toolDiameter + 'mm');
  lines.push('');
  lines.push('G21 ; Units in mm');
  lines.push('G90 ; Absolute positioning');
  lines.push(`G00 Z${config.safeZ.toFixed(3)} ; Safe Z`);
  lines.push(`M03 S${config.spindleSpeed} ; Spindle on`);
  lines.push('');

  switch (config.strategy) {
    case 'contour':
      generateContourToolpath(contours, config, lines);
      break;
    case 'pocket':
      generatePocketToolpath(contours, config, lines);
      break;
    case 'engrave':
      generateEngraveToolpath(contours, config, lines);
      break;
  }

  lines.push('');
  lines.push(`G00 Z${config.safeZ.toFixed(3)} ; Retract to safe Z`);
  lines.push('M05 ; Spindle off');
  lines.push('G00 X0 Y0 ; Return to origin');
  lines.push('M30 ; End program');

  return lines.join('\n');
}

function generateContourToolpath(
  contours: ImageContour[],
  config: GCodeGeneratorConfig,
  lines: string[]
): void {
  lines.push('; === 2D CONTOUR TOOLPATH ===');
  
  const numPasses = Math.ceil(Math.abs(config.finalDepth) / config.passingDepth);

  for (let pass = 1; pass <= numPasses; pass++) {
    const currentDepth = -Math.min(pass * config.passingDepth, Math.abs(config.finalDepth));
    lines.push('');
    lines.push(`; Pass ${pass}/${numPasses} - Depth: ${currentDepth.toFixed(3)}mm`);

    contours.forEach((contour, idx) => {
      if (contour.points.length < 2) return;

      lines.push(`; Contour ${idx + 1}`);
      
      const start = contour.points[0];
      lines.push(`G00 X${start.x.toFixed(3)} Y${start.y.toFixed(3)}`);
      lines.push(`G01 Z${currentDepth.toFixed(3)} F${config.plungeRate}`);

      for (let i = 1; i < contour.points.length; i++) {
        const point = contour.points[i];
        lines.push(`G01 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} F${config.feedRate}`);
      }

      if (contour.isClosed) {
        lines.push(`G01 X${start.x.toFixed(3)} Y${start.y.toFixed(3)} F${config.feedRate}`);
      }

      lines.push(`G00 Z${config.safeZ.toFixed(3)}`);
    });
  }
}

function generatePocketToolpath(
  contours: ImageContour[],
  config: GCodeGeneratorConfig,
  lines: string[]
): void {
  lines.push('; === 2D POCKET TOOLPATH ===');
  
  const numPasses = Math.ceil(Math.abs(config.finalDepth) / config.passingDepth);
  const stepover = (config.toolDiameter * config.stepover) / 100;

  for (let pass = 1; pass <= numPasses; pass++) {
    const currentDepth = -Math.min(pass * config.passingDepth, Math.abs(config.finalDepth));
    lines.push('');
    lines.push(`; Pass ${pass}/${numPasses} - Depth: ${currentDepth.toFixed(3)}mm`);

    contours.forEach((contour, idx) => {
      if (!contour.isClosed || contour.points.length < 3) return;

      lines.push(`; Pocket ${idx + 1}`);
      
      const minX = Math.min(...contour.points.map(p => p.x));
      const maxX = Math.max(...contour.points.map(p => p.x));
      const minY = Math.min(...contour.points.map(p => p.y));
      const maxY = Math.max(...contour.points.map(p => p.y));

      let currentY = minY + config.toolDiameter / 2;
      let direction = 1;

      while (currentY <= maxY - config.toolDiameter / 2) {
        const startX = direction > 0 ? minX + config.toolDiameter / 2 : maxX - config.toolDiameter / 2;
        const endX = direction > 0 ? maxX - config.toolDiameter / 2 : minX + config.toolDiameter / 2;

        lines.push(`G00 X${startX.toFixed(3)} Y${currentY.toFixed(3)}`);
        lines.push(`G01 Z${currentDepth.toFixed(3)} F${config.plungeRate}`);

        lines.push(`G01 X${endX.toFixed(3)} Y${currentY.toFixed(3)} F${config.feedRate}`);

        lines.push(`G00 Z${config.safeZ.toFixed(3)}`);

        currentY += stepover;
        direction *= -1;
      }
    });
  }
}

function generateEngraveToolpath(
  contours: ImageContour[],
  config: GCodeGeneratorConfig,
  lines: string[]
): void {
  lines.push('; === ENGRAVE TOOLPATH ===');
  lines.push(`; Depth: ${(-Math.abs(config.finalDepth)).toFixed(3)}mm`);
  lines.push('');

  contours.forEach((contour, idx) => {
    if (contour.points.length < 2) return;

    lines.push(`; Contour ${idx + 1}`);
    
    const start = contour.points[0];
    lines.push(`G00 X${start.x.toFixed(3)} Y${start.y.toFixed(3)}`);
    lines.push(`G01 Z${(-Math.abs(config.finalDepth)).toFixed(3)} F${config.plungeRate}`);

    for (let i = 1; i < contour.points.length; i++) {
      const point = contour.points[i];
      lines.push(`G01 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} F${config.feedRate}`);
    }

    if (contour.isClosed) {
      lines.push(`G01 X${start.x.toFixed(3)} Y${start.y.toFixed(3)} F${config.feedRate}`);
    }

    lines.push(`G00 Z${config.safeZ.toFixed(3)}`);
  });
}
