import type { SVGConversionOptions } from '@/lib/Constants';
import { CNCConstants } from './Constants';

export class SVGConverter {
  private options: SVGConversionOptions;

  constructor() {
    this.options = {
      scale: 1,
      feedRate: CNCConstants.defaults.feedRate,
      cutDepth: CNCConstants.defaults.cutDepth,
      safeZ: CNCConstants.defaults.safeZ,
    };
  }

  setOptions(options: Partial<SVGConversionOptions>): void {
    this.options = { ...this.options, ...options };
  }

  async convertFile(file: File): Promise<string> {
    const text = await file.text();
    return this.convertSVG(text);
  }

  convertSVG(svgText: string): string {
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
    const svgElement = svgDoc.querySelector('svg');

    if (!svgElement) {
      throw new Error('Invalid SVG file');
    }

    const gcode: string[] = [];
    
    gcode.push('; Generated by CNC Simulator');
    gcode.push('; SVG to G-Code Conversion');
    gcode.push('');
    gcode.push('G21 ; Units in mm');
    gcode.push('G90 ; Absolute positioning');
    gcode.push(`G00 Z${this.options.safeZ.toFixed(3)} ; Move to safe Z`);
    gcode.push('M03 S12000 ; Spindle on');
    gcode.push('');

    this.processSVGElement(svgElement, gcode);

    gcode.push('');
    gcode.push(`G00 Z${this.options.safeZ.toFixed(3)} ; Retract to safe Z`);
    gcode.push('M05 ; Spindle off');
    gcode.push('G00 X0 Y0 ; Return to origin');
    gcode.push('M30 ; End program');

    return gcode.join('\n');
  }

  private processSVGElement(element: Element, gcode: string[]): void {
    const children = Array.from(element.children);

    for (const child of children) {
      const tagName = child.tagName.toLowerCase();

      switch (tagName) {
        case 'path':
          this.processPath(child as SVGPathElement, gcode);
          break;
        case 'line':
          this.processLine(child as SVGLineElement, gcode);
          break;
        case 'polyline':
          this.processPolyline(child as SVGPolylineElement, gcode);
          break;
        case 'polygon':
          this.processPolygon(child as SVGPolygonElement, gcode);
          break;
        case 'rect':
          this.processRect(child as SVGRectElement, gcode);
          break;
        case 'circle':
          this.processCircle(child as SVGCircleElement, gcode);
          break;
        case 'ellipse':
          this.processEllipse(child as SVGEllipseElement, gcode);
          break;
        case 'g':
        case 'svg':
          this.processSVGElement(child, gcode);
          break;
      }
    }
  }

  private processPath(path: SVGPathElement, gcode: string[]): void {
    const pathData = path.getAttribute('d');
    if (!pathData) return;

    const commands = this.parsePathData(pathData);
    let currentX = 0;
    let currentY = 0;
    let firstPoint = true;

    for (const cmd of commands) {
      const points = cmd.points;

      if (cmd.type === 'M' || cmd.type === 'm') {
        currentX = points[0];
        currentY = points[1];
        
        if (firstPoint) {
          gcode.push(`G00 X${(currentX * this.options.scale).toFixed(3)} Y${(currentY * this.options.scale).toFixed(3)} ; Move to start`);
          gcode.push(`G01 Z${this.options.cutDepth.toFixed(3)} F${this.options.feedRate} ; Plunge`);
          firstPoint = false;
        } else {
          gcode.push(`G00 Z${this.options.safeZ.toFixed(3)} ; Lift`);
          gcode.push(`G00 X${(currentX * this.options.scale).toFixed(3)} Y${(currentY * this.options.scale).toFixed(3)} ; Move`);
          gcode.push(`G01 Z${this.options.cutDepth.toFixed(3)} F${this.options.feedRate} ; Plunge`);
        }
      } else if (cmd.type === 'L' || cmd.type === 'l') {
        for (let i = 0; i < points.length; i += 2) {
          currentX = points[i];
          currentY = points[i + 1];
          gcode.push(`G01 X${(currentX * this.options.scale).toFixed(3)} Y${(currentY * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
        }
      } else if (cmd.type === 'H' || cmd.type === 'h') {
        currentX = points[0];
        gcode.push(`G01 X${(currentX * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
      } else if (cmd.type === 'V' || cmd.type === 'v') {
        currentY = points[0];
        gcode.push(`G01 Y${(currentY * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
      } else if (cmd.type === 'Z' || cmd.type === 'z') {
        gcode.push(`G00 Z${this.options.safeZ.toFixed(3)} ; Lift`);
      }
    }

    gcode.push(`G00 Z${this.options.safeZ.toFixed(3)} ; Lift`);
  }

  private parsePathData(pathData: string): Array<{ type: string; points: number[] }> {
    const commands: Array<{ type: string; points: number[] }> = [];
    const regex = /([MmLlHhVvZzCcSsQqTtAa])([-+]?[\d.]+(?:[-+]?[\d.]+)*)?/g;
    let match;
    let currentX = 0;
    let currentY = 0;

    while ((match = regex.exec(pathData)) !== null) {
      const type = match[1];
      const pointsStr = match[2];
      const points: number[] = [];

      if (pointsStr) {
        const numbers = pointsStr.match(/[-+]?[\d.]+/g);
        if (numbers) {
          points.push(...numbers.map(n => parseFloat(n)));
        }
      }

      if (type === 'm' && points.length >= 2) {
        points[0] += currentX;
        points[1] += currentY;
      } else if (type === 'l' && points.length >= 2) {
        for (let i = 0; i < points.length; i += 2) {
          points[i] += currentX;
          points[i + 1] += currentY;
          currentX = points[i];
          currentY = points[i + 1];
        }
      } else if (type === 'h') {
        points[0] += currentX;
      } else if (type === 'v') {
        points[0] += currentY;
      }

      if ((type === 'M' || type === 'm') && points.length >= 2) {
        currentX = points[0];
        currentY = points[1];
      } else if ((type === 'L' || type === 'l') && points.length >= 2) {
        currentX = points[points.length - 2];
        currentY = points[points.length - 1];
      }

      commands.push({ type, points });
    }

    return commands;
  }

  private processLine(line: SVGLineElement, gcode: string[]): void {
    const x1 = parseFloat(line.getAttribute('x1') || '0');
    const y1 = parseFloat(line.getAttribute('y1') || '0');
    const x2 = parseFloat(line.getAttribute('x2') || '0');
    const y2 = parseFloat(line.getAttribute('y2') || '0');

    gcode.push(`G00 X${(x1 * this.options.scale).toFixed(3)} Y${(y1 * this.options.scale).toFixed(3)}`);
    gcode.push(`G01 Z${this.options.cutDepth.toFixed(3)} F${this.options.feedRate}`);
    gcode.push(`G01 X${(x2 * this.options.scale).toFixed(3)} Y${(y2 * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
    gcode.push(`G00 Z${this.options.safeZ.toFixed(3)}`);
  }

  private processPolyline(polyline: SVGPolylineElement, gcode: string[]): void {
    const points = polyline.getAttribute('points');
    if (!points) return;

    const coords = points.trim().split(/[\s,]+/).map(n => parseFloat(n));
    
    if (coords.length < 2) return;

    gcode.push(`G00 X${(coords[0] * this.options.scale).toFixed(3)} Y${(coords[1] * this.options.scale).toFixed(3)}`);
    gcode.push(`G01 Z${this.options.cutDepth.toFixed(3)} F${this.options.feedRate}`);

    for (let i = 2; i < coords.length; i += 2) {
      gcode.push(`G01 X${(coords[i] * this.options.scale).toFixed(3)} Y${(coords[i + 1] * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
    }

    gcode.push(`G00 Z${this.options.safeZ.toFixed(3)}`);
  }

  private processPolygon(polygon: SVGPolygonElement, gcode: string[]): void {
    const points = polygon.getAttribute('points');
    if (!points) return;

    const coords = points.trim().split(/[\s,]+/).map(n => parseFloat(n));
    
    if (coords.length < 2) return;

    gcode.push(`G00 X${(coords[0] * this.options.scale).toFixed(3)} Y${(coords[1] * this.options.scale).toFixed(3)}`);
    gcode.push(`G01 Z${this.options.cutDepth.toFixed(3)} F${this.options.feedRate}`);

    for (let i = 2; i < coords.length; i += 2) {
      gcode.push(`G01 X${(coords[i] * this.options.scale).toFixed(3)} Y${(coords[i + 1] * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
    }

    gcode.push(`G01 X${(coords[0] * this.options.scale).toFixed(3)} Y${(coords[1] * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
    gcode.push(`G00 Z${this.options.safeZ.toFixed(3)}`);
  }

  private processRect(rect: SVGRectElement, gcode: string[]): void {
    const x = parseFloat(rect.getAttribute('x') || '0');
    const y = parseFloat(rect.getAttribute('y') || '0');
    const width = parseFloat(rect.getAttribute('width') || '0');
    const height = parseFloat(rect.getAttribute('height') || '0');

    gcode.push(`G00 X${(x * this.options.scale).toFixed(3)} Y${(y * this.options.scale).toFixed(3)}`);
    gcode.push(`G01 Z${this.options.cutDepth.toFixed(3)} F${this.options.feedRate}`);
    gcode.push(`G01 X${((x + width) * this.options.scale).toFixed(3)} Y${(y * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
    gcode.push(`G01 X${((x + width) * this.options.scale).toFixed(3)} Y${((y + height) * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
    gcode.push(`G01 X${(x * this.options.scale).toFixed(3)} Y${((y + height) * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
    gcode.push(`G01 X${(x * this.options.scale).toFixed(3)} Y${(y * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
    gcode.push(`G00 Z${this.options.safeZ.toFixed(3)}`);
  }

  private processCircle(circle: SVGCircleElement, gcode: string[]): void {
    const cx = parseFloat(circle.getAttribute('cx') || '0');
    const cy = parseFloat(circle.getAttribute('cy') || '0');
    const r = parseFloat(circle.getAttribute('r') || '0');

    const startX = cx + r;
    const startY = cy;

    gcode.push(`G00 X${(startX * this.options.scale).toFixed(3)} Y${(startY * this.options.scale).toFixed(3)}`);
    gcode.push(`G01 Z${this.options.cutDepth.toFixed(3)} F${this.options.feedRate}`);
    gcode.push(`G02 X${(startX * this.options.scale).toFixed(3)} Y${(startY * this.options.scale).toFixed(3)} I${(-r * this.options.scale).toFixed(3)} J0 F${this.options.feedRate}`);
    gcode.push(`G00 Z${this.options.safeZ.toFixed(3)}`);
  }

  private processEllipse(ellipse: SVGEllipseElement, gcode: string[]): void {
    const cx = parseFloat(ellipse.getAttribute('cx') || '0');
    const cy = parseFloat(ellipse.getAttribute('cy') || '0');
    const rx = parseFloat(ellipse.getAttribute('rx') || '0');
    const ry = parseFloat(ellipse.getAttribute('ry') || '0');

    const segments = 32;
    const angleStep = (2 * Math.PI) / segments;

    gcode.push(`G00 X${((cx + rx) * this.options.scale).toFixed(3)} Y${(cy * this.options.scale).toFixed(3)}`);
    gcode.push(`G01 Z${this.options.cutDepth.toFixed(3)} F${this.options.feedRate}`);

    for (let i = 1; i <= segments; i++) {
      const angle = i * angleStep;
      const x = cx + rx * Math.cos(angle);
      const y = cy + ry * Math.sin(angle);
      gcode.push(`G01 X${(x * this.options.scale).toFixed(3)} Y${(y * this.options.scale).toFixed(3)} F${this.options.feedRate}`);
    }

    gcode.push(`G00 Z${this.options.safeZ.toFixed(3)}`);
  }
}
